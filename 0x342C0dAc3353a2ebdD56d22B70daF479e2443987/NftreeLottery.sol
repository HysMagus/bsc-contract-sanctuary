// SPDX-License-Identifier: --ðŸŒ²--

pragma solidity ^0.8.0;

import './SafeMath.sol';

// Get a link to treedefi collectibles BEP721 smart contract
interface ITreedefiForest {
    
    // Transfer collectibles
    function transferFrom(
      address _from,
      address _to,
      uint256 _id
    ) external;
    
    // Fetch owner address
    function getOwner() external returns (address);

}

// Get a link to SEED BEP20 smart contract
interface IBEP20Token {
    
    // Transfer tokens
    function transferFrom(
      address _from,
      address _to,
      uint256 _value
    ) external returns (bool success);

}

/**
 * @title Treedefi Nftree Lottery Version 1.0
 *
 * @author treedefi
 */
contract NftreeLottery {
    
  using SafeMath for uint256; 
  
  // Link to treedefi collectibles
  ITreedefiForest private NFTREE;
  
  // Link to seed token
  IBEP20Token private SEED;
  
  // Burn address for seed token
  address private constant burnAddress = 0x000000000000000000000000000000000000dEaD;
  
  // Revenue collection address
  address public immutable treasury;
  
  // Address of treedefi owner
  address public owner;
  
  // Address of drawer for picking lucky numbers
  address public drawer;
  
  // Fee in form of seed tokens to buy one lottery ticket 
  uint256 public lotteryTicketFee;
  
  // Percentage of seed tokens burned from collected fee
  uint256 public burnPercentage;
  
  // Percentage of discount offered to ticket buyers of previous lottery event 
  uint256 public discountRate;
  
  // Starting Index for lottery event
  uint256 public initialIndex; 
  
  // Assignment Index for lottery ticket number
  uint256 public nextIndex; 
  
  // Index to track lottery event
  uint256 public eventNumber;

  // Index of last finalize lottery event
  uint256 public lastFinalizeEvent;
  
  // Closing time of lottery event
  uint256 public closeTime;
  
  // Token Id of trees in prize pool
  uint256[] public treeId;
  
  // Luckey numbers generated by drawer/owner
  uint256[] private _luckeyNumbers;
  
  // Mapping from luckey number to _isGenerated
  mapping(uint256 => bool) private _isGenerated;
  
  // Mapping from event number to lotteryData
  mapping(uint256 => LotteryEvent) public lotteryData;
  
  // Mapping from event number to winners
  mapping(uint256 => address[]) public winners;

  // Mapping from event number to winningNumbers
  mapping(uint256 => uint256[]) public winningNumbers;

  // Mapping from lottery ticket number to buyer address
  mapping(uint256 => address) public lotteryTicket;
  
  // Mapping from buyer address to ticket numbers for given lottery event
  mapping(address => mapping(uint256=> uint256[])) public lotteryTicketNumber;
  
  // Status of lottery event
  bool public isLotteryActive;
  
  // `LotteryEvent` records data of lottery event
  struct LotteryEvent {
    uint8 _numberOfRewards;
    uint256 _numberOfParticipants;
    uint256 _numberOfTicketsSold;
  }
  
  /**
	 * @dev Fired in initializeLottery() when lottery event initialized  
	 *      successfully by owner
	 *
	 * @param _eventNumber assigned index to lottery event
	 * @param _fee number of seed tokens to buy a ticket
	 * @param _burn burning percentage
	 * @param _discount discount rate for previous buyers
	 * @param _duration timeperiod of lottery event in seconds
	 */
  event Start(
    uint256 indexed _eventNumber,
    uint256 _fee,
    uint256 _burn,
    uint256 _discount,
    uint256 _duration
  );
  
  /**
	 * @dev Fired in finalizeLottery() and revokeLottery() when lottery event  
	 *      successfully deactivated
	 *
	 * @param _eventNumber assigned index to lottery event
	 * @param _closeTime timestamp of deactivation
	 * @param _finalized status of finalization of lottery event
	 */
  event End(
    uint256 indexed _eventNumber,
    uint256 _closeTime,
    bool _finalized
  );
  
  /**
	 * @dev Fired in buyLotteryTicket() when lottery tickets bought
	 *      successfully by user
	 *
	 * @param _by buyer address
	 * @param _eventNumber assigned index to lottery event
	 * @param _tickets number of tickets bought
	 */
  event Bought(
    address indexed _by,
    uint256 _eventNumber,
    uint256 _tickets
  );
  
  /**
	 * @dev Fired in generateLuckeyNumbers() when owner or drawer
	 *      attempts to generate luckey numbers
	 *
	 * @param _by owner/drawer address
	 * @param _eventNumber assigned index to lottery event
	 * @param _totalNumbersGenerated length of luckey numbers
	 */
  event Generated(
    address indexed _by,  
    uint256 indexed _eventNumber,
    uint256 _totalNumbersGenerated
  );
  
  // To restrict access
  modifier onlyOwner() {
    
    require(
      owner == msg.sender,
      "Treedefi: Not an owner"
    );
    
    _;
  
  }
  
  /**
	 * @dev Creates/deploys Treedefi Nftree Lottery Version 1.0
	 *
	 * @param nftree_ address of treedefi collectibles
	 * @param seed_ address of seed tokens
	 * @param treasury_ address of treasury
	 * @param initiateFrom_ initial serial number for lottery (some fancy initializer i.e.07052022)
	 */
  constructor(address nftree_, address seed_, address treasury_, uint256 initiateFrom_) {
    
    require(
        nftree_ != address(0) && seed_ != address(0) && treasury_ != address(0)
        && initiateFrom_ > 0,
        "Treedefi: Invalid Input"
    );
    
    //---Setup smart contract internal state---//
    NFTREE = ITreedefiForest(nftree_);
    
    SEED = IBEP20Token(seed_);
    
    treasury = treasury_;
    
    owner = NFTREE.getOwner();
    
    initialIndex = initiateFrom_;
    
    nextIndex = initiateFrom_;
    
  }
  
  /** 
     * @notice upgrades admin address to existing NFTREE V2 owner
     *        as ownership of NFTREE V2 is transferable
     */
  function upgradeAdminAddress() external {
    
    // Update owner address
    owner = NFTREE.getOwner();

  }
  
  /** 
    * @dev Initialize lottery event and declare prize pool
    * 
    * @notice restricted function, should be called by owner only
    * @notice fails if previous lottery event is running
    * @notice owner can assign upto 10 trees(maximum) in prize pool 
    * 
    * @param treeId_ array defines token Id of trees in prize pool
    * @param fee_ unsigned integer defines number of seed tokens to buy a ticket
	* @param burn_ unsigned integer defines burning percentage
	* @param discount_ unsigned integer defines discount rate for previous buyers
	* @param duration_ unsigned integer defines timeperiod of lottery event in seconds
	*/
  function initializeLottery(
    uint256[] memory treeId_,
    uint256 fee_,
    uint256 burn_,
    uint256 discount_,
    uint256 duration_
  ) 
  external 
  onlyOwner
  {
    
    require(!isLotteryActive, "Treedefi: Active lottery exists");
    
    require(
        fee_ > 0 && duration_ > 0 && burn_ >= 0 && burn_ <= 100 && discount_ >= 0 && discount_ <= 100 
        && treeId_.length > 0 && treeId_.length <= 10,
        "Treedefi: Invalid Inputs"
    );
    
    for(uint8 i; i < treeId_.length ; i++) {
        
        // Transfer trees to lottery contract
        NFTREE.transferFrom(msg.sender, address(this), treeId_[i]);        
        
        // Update prize pool
        treeId.push(treeId_[i]);
        
    }
    
    //--Set internal state--//
    lotteryTicketFee = fee_;
    
    burnPercentage = burn_;
    
    discountRate = discount_;
    
    initialIndex = nextIndex;
    
    eventNumber++;
    
    closeTime = duration_.add(block.timestamp);
    
    lotteryData[eventNumber]._numberOfRewards = uint8(treeId_.length);
    
    isLotteryActive = true;
    
    // Emits an event
    emit Start(eventNumber, fee_, burn_, discount_, duration_);
    
  }
  
  /** 
    * @dev Finalize lottery event and declare winners
    * 
    * @notice fails if called before event finished
    * @notice fails if called before generating luckey numbers
    */
  function finalizeLottery() external {
    
    require(isLotteryActive, "Treedefi: No active lottery exists");
    
    require(block.timestamp > closeTime, "Treedefi: Lottery event is running");
    
    require(treeId.length == _luckeyNumbers.length, "Treedefi: Insufficient luckey numbers");
    
    for(uint8 i; i < treeId.length; i++){
        
        // Get a number from generated luckey numbers
        uint256 _number = _luckeyNumbers[i]; 
        
        // Free the number from generated flag
        _isGenerated[_number] = false;
        
        // Get a lottery number
        uint256 _winningNumber = _number.add(initialIndex);
        
        // Record winning lottery number
        winningNumbers[eventNumber].push(_winningNumber);
        
        // Get address of winning lottey number
        address _winner = lotteryTicket[_winningNumber];
        
        // Record winner's address
        winners[eventNumber].push(_winner);
        
        // Transfer prize to winner
        NFTREE.transferFrom(address(this), _winner, treeId[i]);
    
    }
    
    // Record event index
    lastFinalizeEvent = eventNumber;

    //--Unset internal state--//
    delete drawer;
    
    delete closeTime;
    
    delete treeId;
    
    delete _luckeyNumbers;
    
    isLotteryActive = false;
    
    // Emits an event
    emit End(eventNumber, block.timestamp, true);
  
  }
  
  /** 
    * @dev Revoke lottery event and remove prize pool
    * 
    * @notice restricted function, should be called by owner only
    * @notice fails if lottery event is not active
    * @notice ends active lottery event without declaring winners
    */
  function revokeLottery() external onlyOwner {
      
    require(isLotteryActive, "Treedefi: No active lottery exists");
    
    for(uint8 i; i < treeId.length; i++){
        
        // Transfer trees to owner
        NFTREE.transferFrom(address(this), msg.sender, treeId[i]);
    
    }
    
    //--Reset internal state--//
    delete drawer;
    
    delete closeTime;
    
    delete treeId;
    
    delete _luckeyNumbers;
    
    isLotteryActive = false;
    
    // Emits an event
    emit End(eventNumber, block.timestamp, false);
    
  }
  
  /** 
    * @dev Adds drawer address to give access of luckey numbers generation
    * 
    * @notice restricted function, should be called by owner only
    * @notice fails if lottery event is not active
    * 
    * @param drawer_ defines address of drawer
    */
  function addDrawer(address drawer_) external onlyOwner {
    
    require(isLotteryActive, "Treedefi: No active lottery exists");
    
    require(drawer_ != address(0), "Treedefi: Invalid address");
  
    // Set drawer address
    drawer = drawer_;
    
  }
  
  /** 
    * @dev Removes drawer address to restrict access for luckey number generation
    * 
    * @notice restricted function, should be called by owner only
    * @notice fails if lottery event is not active
    */
  function removeDrawer() external onlyOwner {
    
    require(isLotteryActive, "Treedefi: No active lottery exists");
    
    require(drawer != address(0), "Treedefi: Drawer not found");
    
    // Unset drawer address
    drawer = address(0);
    
  }
  
  /** 
    * @dev Assignes lottry tickets to users by charging lottery fees
    * 
    * @notice users can buy upto 25 tickets in single transaction
    * @notice fails if lottery event is not active or over
    * 
    * @param numberOfTickets_ unsigned integer defines number of tickets that user wants to buy
    */
  function buyLotteryTicket(uint256 numberOfTickets_) external {
    
    require(isLotteryActive, "Treedefi: No active lottery exists");
    
    require(block.timestamp <= closeTime, "Treedefi: Lottery event is over");
    
    require(numberOfTickets_ > 0 && numberOfTickets_ <= 25, "Treedefi: Invalid Input");
    
    // Get index of previous event
    uint256 _previousEvent = eventNumber.sub(1);
    
    // Calculates fee to buy lottery tickets
    uint256 _fee = (lotteryTicketNumber[msg.sender][_previousEvent].length > 0)?
                    lotteryTicketFee.mul(numberOfTickets_).mul(100-discountRate).div(100):
                    lotteryTicketFee.mul(numberOfTickets_);
    
    // Calculates burn fee              
    uint256 _burnFee = _fee.mul(burnPercentage).div(100);
    
    // Calculates amount that will transferred to treasury
    uint256 _lotteryFee = _fee.sub(_burnFee); 
    
    // Transfer burn fee if non-zero
    (_burnFee > 0) && SEED.transferFrom(msg.sender, burnAddress, _burnFee);
    
    // Transfer lottery fee if non-zero
    (_lotteryFee > 0) && SEED.transferFrom(msg.sender, treasury, _lotteryFee);
    
    //--------------------Set internal state--------------------// 
    
    if(lotteryTicketNumber[msg.sender][eventNumber].length == 0){
        lotteryData[eventNumber]._numberOfParticipants++;
    }
    
    for(uint i = 0; i < numberOfTickets_; i++) {
        
        lotteryTicket[nextIndex] = msg.sender;
        
        lotteryTicketNumber[msg.sender][eventNumber].push(nextIndex);
        
        nextIndex++;
        
        lotteryData[eventNumber]._numberOfTicketsSold++;
        
    }
    
    // Emits an event
    emit Bought(msg.sender, eventNumber, numberOfTickets_);
    
  }
  
  /**
    * @dev Returns number of lottery tickets bought by given address for given lottery event
    * 
    * @param buyer_ address defines address of lottery tickets buyer
    * @param eventNumber_ unsigned integer defines index number of event
    */
  function lotteryTicketLength(address buyer_, uint256 eventNumber_) 
    external
    view
    returns(uint256)
  {
    return lotteryTicketNumber[buyer_][eventNumber_].length;
  }
  
  /**
    * @dev Returns number of luckey numbers generated by drawer/owner
    */
  function luckeyNumbersLength() 
    external
    view
    returns(uint256)
  {
    return _luckeyNumbers.length;
  }

  /** 
    * @dev Generate luckey numbers upto prize pool length
    * 
    * @notice restricted function, should be called by owner or drawer only
    * @notice fails if lottery event is not active or running
    * @notice try upto 25 (maximum) times to generate luckey number
    * @notice stops execution if required luckey numbers are generated
    */
  function generateLuckeyNumbers()
    external
  {
      
    require(isLotteryActive, "Treedefi: No active lottery exists");
    
    require(block.timestamp > closeTime, "Treedefi: Lottery event is running");
    
    require(
        msg.sender == drawer || msg.sender == owner,
        "Treedefi: Not authorized"
    );
    
    for(uint i; i <= 25; i++) {
        
        // Get a modified number
        uint256 _salt = i.mul(i.add(_luckeyNumbers.length)); 
        
        // Get a random number 
        uint256 _number = _getLuckeyNumber(_salt).mod(nextIndex.sub(initialIndex)); 
        
        // Checks if number already generated before
        if(!_isGenerated[_number]){
            
            // Mark luckey number as generated
            _isGenerated[_number] = true;    
            
            // Record luckey number
            _luckeyNumbers.push(_number);
            
        }
        
        // Checks and return if required luckey numbers are generated
        if(treeId.length == _luckeyNumbers.length){
            return;
        }
        
    }
    
    // Emits an event
    emit Generated(msg.sender, eventNumber, _luckeyNumbers.length);
    
  }
  
  /** @dev Called internally to generate random numbers
     * 
     *@param salt_ unsigned integer to add more complexivity in random number generation
     *@return uint256 random number between 0 to 99999
     */
  function _getLuckeyNumber(uint256 salt_)
    internal
    view
    returns(uint256)
  {
    // Generates random number
    uint256 seed = uint256(keccak256(abi.encodePacked(
        block.timestamp + block.difficulty + salt_ +
        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (block.timestamp)) +
        block.gaslimit + 
        ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (block.timestamp)) +
        block.number
    )));
    
    // Returns random number
    return (seed - ((seed / 100000) * 100000));
  
  }
  
}
